<h2 id="mapping-element-collection">Mapping a collection of elements</h2>
<h3 id="mapping-element-collection-basis">Declaring the collection</h3>
<p>To map a <code>Collection</code> of elements (not entities) you must use the <code>mapCollection(..)</code> method,
    which takes as second argument the element type.</p>
<pre><code class="language-java">FluentMappings.entityBuilder(Person.class, Long.class)
    .mapCollection(Person::getNicknames, String.class)
</code></pre>

<p>If your element type is complex (more than one column) you shall give the bean configuration as a third argument.</p>
<pre><code class="language-java">FluentMappings.entityBuilder(Person.class, Long.class)
    .mapCollection(Person::getTimestamps, Timestamp.class, FluentMappings.embeddableBuilder(Timestamp.class)
            .map(Timestamp::getCreationDate)
            .map(Timestamp::getModificationDate))
</code></pre>

<h3 id="mapping-element-collection-initialization">Collection initialization</h3>
<p>
    By default, Stalactite will choose a default implementation for your collection (e.g., <code>ArrayList</code> for <code>List</code>).
    You can override this by providing a custom factory using <code>initializeWith(..)</code>.
</p>
<pre><code class="language-java">FluentMappings.entityBuilder(Country.class, Long.class)
    .mapKey(Country::getId, IdentifierPolicy.databaseAutoIncrement())
    .mapCollection(Country::getCities, String.class)
    .initializeWith(HashSet::new)
</code></pre>

<h3 id="mapping-element-collection-table-customization">Table and Column customization</h3>
<p>
    By default, element collections are stored in a separate table named according to the property name with default
    column names. You can customize the table and column names and sizes by calling a set of dedicated methods :
</p>
<ul>
    <li><code>onTable(String)</code>: sets the name of the target table.</li>
    <li><code>onTable(Table)</code>: uses a specific <code>Table</code> object, allowing for precise column definitions.</li>
    <li><code>reverseJoinColumn(String)</code>: specifies the name of the foreign key column pointing back to the owner entity.</li>
    <li><code>elementColumnName(String)</code>: specifies the name of the column storing the collection elements.</li>
    <li><code>elementColumnSize(Size)</code>: specifies the <code>Size</code> of the column storing the collection elements.</li>
</ul>

<pre><code class="language-java">FluentMappings.entityBuilder(Country.class, Long.class)
    .mapKey(Country::getId, IdentifierPolicy.databaseAutoIncrement())
    .mapCollection(Country::getCities, String.class)
    .onTable("COUNTRY_CITY")
    .reverseJoinColumn("country_id")
</code></pre>

<h3 id="mapping-element-collection-indexing">Indexing collections</h3>
<p>
    For ordered collections like <code>List</code>, you might want to preserve the element order in the database.
    Use <code>indexed()</code> to use the default index column name (<code>idx</code>), or <code>indexedBy(String columnName)</code> to specify your own.
</p>
<pre><code class="language-java">FluentMappings.entityBuilder(Country.class, Long.class)
    .mapKey(Country::getId, IdentifierPolicy.databaseAutoIncrement())
    .mapCollection(Country::getCities, String.class)
    .indexedBy("order_index")
</code></pre>