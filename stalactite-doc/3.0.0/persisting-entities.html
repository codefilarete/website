<h1 id="persisting-entities">Persisting entities</h1>
<p>Building your mapping through <code>FluentMappings.entityBuilder(..).build(persistenceContext)</code> let&rsquo;s you get an
	<code>EntityPersister</code> which then allows one to apply usual commands on your entities : </p>
<ul>
	<li><code>EntityPersister.insert(entity)</code> will insert the given entity with an insert order</li>
	<li><code>EntityPersister.update(entity)</code> will update the given entity with an update order after having loaded it from the database to
		compute differences between it and the given one. It takes optimistic locking into account
	</li>
	<li><code>EntityPersister.persist(entity)</code> will insert or update the given entity according to its persistence state, which is based on entity
		id and depends on id policy. Please note that to perform the update, the entity is loaded from the database since it is delegated to <code>update(entity)</code>
	</li>
	<li><code>EntityPersister.delete(entity)</code> will delete the given entity with a delete order. It takes optimistic locking into account</li>
	<li><code>EntityPersister.select(id)</code> will load a whole entity graph with a select order, or several of them if the graph is too complex to be
		loaded through a single select with join (polymorphism may be a good reason)
	</li>
</ul>
<section class="hint info">
<p>All of these methods have a massive variant signature accepting an <code>Iterable</code>. </p>
</section>


<p>Above were the basic commands, but more advanced ones exist :</p>
<ul>
	<li><code>EntityPersister.update(entity, allColumnStatement)</code> allows you to decide weither or not all columns will be contained in SQL
		order, if not (second argument set to<code>false</code>), only modified columns will be present in SQL. Be aware that using it as such may
		have some performance impact since JDBC batch will have few chances to be activated while updating multiple entities, unless their modifications
		target the same properties. This option is propagated to all graph entities.
	</li>
	<li><code>EntityPersister.update(id, entityConsumer)</code> loads entity according to its id, then applies the given Consumer on it and updates the
		result. It's a shortcut for those who want to apply some modifications on an entity without having to explicitly load it. Hence, this can be seen as
		a helper for the Command Pattern where the whole entity may not be given by the Command, but only properties that must be modified.
	</li>
	<li><code>EntityPersister.updateById(id)</code> will update the given entity with an update order on its primary key. As a difference with <code>update(entity)</code>
		it doesn&rsquo;t take optimistic lock into account
	</li>
	<li><code>EntityPersister.deleteById(id)</code> will delete the given entity with a delete order on its primary key. As a difference with <code>delete(entity)</code>
		it doesn&rsquo;t take optimistic lock into account
	</li>
</ul>
