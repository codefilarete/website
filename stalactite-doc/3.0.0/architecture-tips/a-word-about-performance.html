<h2 id="a-word-about-performance">A word about performance</h2>
<p>Stalactite uses JDBC Batch for inserts, updates and deletes. But users have to keep in mind that the identifier policy
	can corrupt inserts performance.</p>
<h3 id="take-caution-to-after-insert-identifier-policy-and-massive-insert">Take caution to after-insert identifier policy and massive insert</h3>
<p>If you use Stalactite to insert values into a single table, then you don&rsquo;t have to worry so much about identifier policy. But if you&rsquo;re
	using Stalactite to simplify your work of persisting an object graph and expect good performance then, you may encounter some trouble if you used
	after-insert policy.</p>
<p>JDBC batch is used on PreparedStatement, which then expects to have all its values defined, so in the case of relational objects, and in particular with
	one-to-one owned by source entity, it should know the target ids before persisting them to fill the owning column, which is impossible with
	after-insert policy on target entities. As a consequence, in such a situation, Stalactite should persist target entities before the aggregate root and extends this
	mechanism to the whole graph. As a consequence, to benefit from JDBC batch, after-insert policy needs a different graph iteration algorithm than
	other policies. It may be possible, but not done yet !</p>
