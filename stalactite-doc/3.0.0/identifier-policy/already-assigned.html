<h3 id="already-assigned">Already assigned</h3>
<p>As the name suggests, this policy indicates that the entity identifier is manually assigned by the application code
	rather than being generated by Stalactite. Its usage is straightforward:</p>
<pre><code class="language-java">FluentMappings.entityBuilder(Car.class, long.class)
    .mapKey(Car::getId, IdentifierPolicy.alreadyAssigned())
    .map(Car::getModel)
</code></pre>
<section class="hint success">
	<p>This policy accepts any type of identifier. For instance, UUID is a good candidate, but a more business one can also be used.</p>
</section>

<section class="hint warn">
<p>By essence, the persistent state of such entities can't be easely determined: no information on entities may help
	to distinguish the operation to do when the <code>EntityPersister.persist(..)</code> method is called : insert or
	update ? As a consequence, by default, a database <code>select</code> is made to find out which entities are
	already inserted. However, Stalactite is opened to let your application record such status and offer a mechanism to
	optimize the<code>persist(..)</code> algorithm: you can pass two functions to the <code>alreadyAssigned(..)</code>
	method that:
	<ul>
		<li>mark an entity as persisted</li>
		<li>let Stalactite know if an entity is already persisted</li>
	</ul>
	</p>
	Some simple implementations can be:
	<ul>
		<li>a cache system, but it brings all cache problems</li>
		<li>a <code>boolean</code> field in the entity, but it impacts the business code</li>
	</ul>
	Here is an example of the latter:
<pre><code class="language-java">FluentMappings.entityBuilder(Car.class, long.class)
    .mapKey(Car::getId, IdentifierPolicy.alreadyAssigned(Car::markAsPersisted, Car::isPersisted))
    .map(Car::getModel)
</code></pre>
	As you can see, the <code>already-assigned</code> policy can be cumbersome when combined with the
	<code>persist(..)</code> method. And note that even if you call <code>insert(..)</code> on your entity, Stalactite
	will trigger a <code>persist</code> invokation on related entities to cleanly manage a merge with the database.
</section>

